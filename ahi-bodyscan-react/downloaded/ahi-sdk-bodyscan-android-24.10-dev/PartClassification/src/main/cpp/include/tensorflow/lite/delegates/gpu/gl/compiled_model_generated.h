// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_
#define FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

namespace tflite {
namespace gpu {
namespace gl {
namespace data {

struct Program;

struct ProgramBinary;

struct DataFloat;

struct DataInt32;

struct DataUint32;

struct UniformParameter;

struct Object;

struct ObjectRef;

struct ObjectData;

struct CompiledModel;

struct Parameters;

enum class ParameterType : int8_t {
  INT32 = 0,
  UINT32 = 1,
  FLOAT32 = 2,
  INT32_2 = 3,
  MIN = INT32,
  MAX = INT32_2
};

inline const ParameterType (&EnumValuesParameterType())[4] {
  static const ParameterType values[] = {
    ParameterType::INT32,
    ParameterType::UINT32,
    ParameterType::FLOAT32,
    ParameterType::INT32_2
  };
  return values;
}

inline const char * const *EnumNamesParameterType() {
  static const char * const names[] = {
    "INT32",
    "UINT32",
    "FLOAT32",
    "INT32_2",
    nullptr
  };
  return names;
}

inline const char *EnumNameParameterType(ParameterType e) {
  if (e < ParameterType::INT32 || e > ParameterType::INT32_2) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesParameterType()[index];
}

enum class DataType : int8_t {
  UNKNOWN = 0,
  FLOAT32 = 1,
  FLOAT16 = 2,
  INT32 = 3,
  INT16 = 4,
  MIN = UNKNOWN,
  MAX = INT16
};

inline const DataType (&EnumValuesDataType())[5] {
  static const DataType values[] = {
    DataType::UNKNOWN,
    DataType::FLOAT32,
    DataType::FLOAT16,
    DataType::INT32,
    DataType::INT16
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[] = {
    "UNKNOWN",
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "INT16",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (e < DataType::UNKNOWN || e > DataType::INT16) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class DataVariant : uint8_t {
  NONE = 0,
  DataInt32 = 1,
  DataFloat = 2,
  DataUint32 = 3,
  MIN = NONE,
  MAX = DataUint32
};

inline const DataVariant (&EnumValuesDataVariant())[4] {
  static const DataVariant values[] = {
    DataVariant::NONE,
    DataVariant::DataInt32,
    DataVariant::DataFloat,
    DataVariant::DataUint32
  };
  return values;
}

inline const char * const *EnumNamesDataVariant() {
  static const char * const names[] = {
    "NONE",
    "DataInt32",
    "DataFloat",
    "DataUint32",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataVariant(DataVariant e) {
  if (e < DataVariant::NONE || e > DataVariant::DataUint32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataVariant()[index];
}

template<typename T> struct DataVariantTraits {
  static const DataVariant enum_value = DataVariant::NONE;
};

template<> struct DataVariantTraits<DataInt32> {
  static const DataVariant enum_value = DataVariant::DataInt32;
};

template<> struct DataVariantTraits<DataFloat> {
  static const DataVariant enum_value = DataVariant::DataFloat;
};

template<> struct DataVariantTraits<DataUint32> {
  static const DataVariant enum_value = DataVariant::DataUint32;
};

bool VerifyDataVariant(flatbuffers::Verifier &verifier, const void *obj, DataVariant type);
bool VerifyDataVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class AccessType : int8_t {
  READ = 0,
  WRITE = 1,
  READ_WRITE = 2,
  MIN = READ,
  MAX = READ_WRITE
};

inline const AccessType (&EnumValuesAccessType())[3] {
  static const AccessType values[] = {
    AccessType::READ,
    AccessType::WRITE,
    AccessType::READ_WRITE
  };
  return values;
}

inline const char * const *EnumNamesAccessType() {
  static const char * const names[] = {
    "READ",
    "WRITE",
    "READ_WRITE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccessType(AccessType e) {
  if (e < AccessType::READ || e > AccessType::READ_WRITE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAccessType()[index];
}

enum class ObjectType : int8_t {
  UNKNOWN = 0,
  BUFFER = 1,
  TEXTURE = 2,
  MIN = UNKNOWN,
  MAX = TEXTURE
};

inline const ObjectType (&EnumValuesObjectType())[3] {
  static const ObjectType values[] = {
    ObjectType::UNKNOWN,
    ObjectType::BUFFER,
    ObjectType::TEXTURE
  };
  return values;
}

inline const char * const *EnumNamesObjectType() {
  static const char * const names[] = {
    "UNKNOWN",
    "BUFFER",
    "TEXTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectType(ObjectType e) {
  if (e < ObjectType::UNKNOWN || e > ObjectType::TEXTURE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectType()[index];
}

enum class ObjectVariant : uint8_t {
  NONE = 0,
  ObjectData = 1,
  ObjectRef = 2,
  MIN = NONE,
  MAX = ObjectRef
};

inline const ObjectVariant (&EnumValuesObjectVariant())[3] {
  static const ObjectVariant values[] = {
    ObjectVariant::NONE,
    ObjectVariant::ObjectData,
    ObjectVariant::ObjectRef
  };
  return values;
}

inline const char * const *EnumNamesObjectVariant() {
  static const char * const names[] = {
    "NONE",
    "ObjectData",
    "ObjectRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectVariant(ObjectVariant e) {
  if (e < ObjectVariant::NONE || e > ObjectVariant::ObjectRef) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectVariant()[index];
}

template<typename T> struct ObjectVariantTraits {
  static const ObjectVariant enum_value = ObjectVariant::NONE;
};

template<> struct ObjectVariantTraits<ObjectData> {
  static const ObjectVariant enum_value = ObjectVariant::ObjectData;
};

template<> struct ObjectVariantTraits<ObjectRef> {
  static const ObjectVariant enum_value = ObjectVariant::ObjectRef;
};

bool VerifyObjectVariant(flatbuffers::Verifier &verifier, const void *obj, ObjectVariant type);
bool VerifyObjectVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ObjectSize : uint8_t {
  NONE = 0,
  Uint1 = 1,
  Uint2 = 2,
  Uint3 = 3,
  MIN = NONE,
  MAX = Uint3
};

inline const ObjectSize (&EnumValuesObjectSize())[4] {
  static const ObjectSize values[] = {
    ObjectSize::NONE,
    ObjectSize::Uint1,
    ObjectSize::Uint2,
    ObjectSize::Uint3
  };
  return values;
}

inline const char * const *EnumNamesObjectSize() {
  static const char * const names[] = {
    "NONE",
    "Uint1",
    "Uint2",
    "Uint3",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectSize(ObjectSize e) {
  if (e < ObjectSize::NONE || e > ObjectSize::Uint3) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectSize()[index];
}

template<typename T> struct ObjectSizeTraits {
  static const ObjectSize enum_value = ObjectSize::NONE;
};

template<> struct ObjectSizeTraits<Uint1> {
  static const ObjectSize enum_value = ObjectSize::Uint1;
};

template<> struct ObjectSizeTraits<Uint2> {
  static const ObjectSize enum_value = ObjectSize::Uint2;
};

template<> struct ObjectSizeTraits<Uint3> {
  static const ObjectSize enum_value = ObjectSize::Uint3;
};

bool VerifyObjectSize(flatbuffers::Verifier &verifier, const void *obj, ObjectSize type);
bool VerifyObjectSizeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Program FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECTS = 4,
    VT_PARAMETERS = 6,
    VT_NUMBER_WORKGROUPS = 8,
    VT_WORKGROUP_SIZE = 10,
    VT_SHADER_INDEX = 12,
    VT_BINARY = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<Object>> *objects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Object>> *>(VT_OBJECTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UniformParameter>> *parameters() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UniformParameter>> *>(VT_PARAMETERS);
  }
  const Uint3 *number_workgroups() const {
    return GetPointer<const Uint3 *>(VT_NUMBER_WORKGROUPS);
  }
  const Uint3 *workgroup_size() const {
    return GetPointer<const Uint3 *>(VT_WORKGROUP_SIZE);
  }
  uint32_t shader_index() const {
    return GetField<uint32_t>(VT_SHADER_INDEX, 0);
  }
  const ProgramBinary *binary() const {
    return GetPointer<const ProgramBinary *>(VT_BINARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBJECTS) &&
           verifier.VerifyVector(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyOffset(verifier, VT_NUMBER_WORKGROUPS) &&
           verifier.VerifyTable(number_workgroups()) &&
           VerifyOffset(verifier, VT_WORKGROUP_SIZE) &&
           verifier.VerifyTable(workgroup_size()) &&
           VerifyField<uint32_t>(verifier, VT_SHADER_INDEX) &&
           VerifyOffset(verifier, VT_BINARY) &&
           verifier.VerifyTable(binary()) &&
           verifier.EndTable();
  }
};

struct ProgramBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects) {
    fbb_.AddOffset(Program::VT_OBJECTS, objects);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniformParameter>>> parameters) {
    fbb_.AddOffset(Program::VT_PARAMETERS, parameters);
  }
  void add_number_workgroups(flatbuffers::Offset<Uint3> number_workgroups) {
    fbb_.AddOffset(Program::VT_NUMBER_WORKGROUPS, number_workgroups);
  }
  void add_workgroup_size(flatbuffers::Offset<Uint3> workgroup_size) {
    fbb_.AddOffset(Program::VT_WORKGROUP_SIZE, workgroup_size);
  }
  void add_shader_index(uint32_t shader_index) {
    fbb_.AddElement<uint32_t>(Program::VT_SHADER_INDEX, shader_index, 0);
  }
  void add_binary(flatbuffers::Offset<ProgramBinary> binary) {
    fbb_.AddOffset(Program::VT_BINARY, binary);
  }
  explicit ProgramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProgramBuilder &operator=(const ProgramBuilder &);
  flatbuffers::Offset<Program> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Program>(end);
    return o;
  }
};

inline flatbuffers::Offset<Program> CreateProgram(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Object>>> objects = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UniformParameter>>> parameters = 0,
    flatbuffers::Offset<Uint3> number_workgroups = 0,
    flatbuffers::Offset<Uint3> workgroup_size = 0,
    uint32_t shader_index = 0,
    flatbuffers::Offset<ProgramBinary> binary = 0) {
  ProgramBuilder builder_(_fbb);
  builder_.add_binary(binary);
  builder_.add_shader_index(shader_index);
  builder_.add_workgroup_size(workgroup_size);
  builder_.add_number_workgroups(number_workgroups);
  builder_.add_parameters(parameters);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline flatbuffers::Offset<Program> CreateProgramDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Object>> *objects = nullptr,
    const std::vector<flatbuffers::Offset<UniformParameter>> *parameters = nullptr,
    flatbuffers::Offset<Uint3> number_workgroups = 0,
    flatbuffers::Offset<Uint3> workgroup_size = 0,
    uint32_t shader_index = 0,
    flatbuffers::Offset<ProgramBinary> binary = 0) {
  auto objects__ = objects ? _fbb.CreateVector<flatbuffers::Offset<Object>>(*objects) : 0;
  auto parameters__ = parameters ? _fbb.CreateVector<flatbuffers::Offset<UniformParameter>>(*parameters) : 0;
  return tflite::gpu::gl::data::CreateProgram(
      _fbb,
      objects__,
      parameters__,
      number_workgroups,
      workgroup_size,
      shader_index,
      binary);
}

struct ProgramBinary FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_BINARY = 6
  };
  uint32_t format() const {
    return GetField<uint32_t>(VT_FORMAT, 0);
  }
  const flatbuffers::Vector<uint8_t> *binary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BINARY) &&
           verifier.VerifyVector(binary()) &&
           verifier.EndTable();
  }
};

struct ProgramBinaryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(uint32_t format) {
    fbb_.AddElement<uint32_t>(ProgramBinary::VT_FORMAT, format, 0);
  }
  void add_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary) {
    fbb_.AddOffset(ProgramBinary::VT_BINARY, binary);
  }
  explicit ProgramBinaryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProgramBinaryBuilder &operator=(const ProgramBinaryBuilder &);
  flatbuffers::Offset<ProgramBinary> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgramBinary>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgramBinary> CreateProgramBinary(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary = 0) {
  ProgramBinaryBuilder builder_(_fbb);
  builder_.add_binary(binary);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgramBinary> CreateProgramBinaryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t format = 0,
    const std::vector<uint8_t> *binary = nullptr) {
  auto binary__ = binary ? _fbb.CreateVector<uint8_t>(*binary) : 0;
  return tflite::gpu::gl::data::CreateProgramBinary(
      _fbb,
      format,
      binary__);
}

struct DataFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DataFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(DataFloat::VT_DATA, data);
  }
  explicit DataFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataFloatBuilder &operator=(const DataFloatBuilder &);
  flatbuffers::Offset<DataFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataFloat> CreateDataFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  DataFloatBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataFloat> CreateDataFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<float>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataFloat(
      _fbb,
      data__);
}

struct DataInt32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DataInt32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int32_t>> data) {
    fbb_.AddOffset(DataInt32::VT_DATA, data);
  }
  explicit DataInt32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataInt32Builder &operator=(const DataInt32Builder &);
  flatbuffers::Offset<DataInt32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataInt32>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataInt32> CreateDataInt32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> data = 0) {
  DataInt32Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataInt32> CreateDataInt32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int32_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataInt32(
      _fbb,
      data__);
}

struct DataUint32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct DataUint32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(DataUint32::VT_DATA, data);
  }
  explicit DataUint32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataUint32Builder &operator=(const DataUint32Builder &);
  flatbuffers::Offset<DataUint32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataUint32>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataUint32> CreateDataUint32(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  DataUint32Builder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataUint32> CreateDataUint32Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateDataUint32(
      _fbb,
      data__);
}

struct UniformParameter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  ParameterType type() const {
    return static_cast<ParameterType>(GetField<int8_t>(VT_TYPE, 0));
  }
  DataVariant data_type() const {
    return static_cast<DataVariant>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const DataInt32 *data_as_DataInt32() const {
    return data_type() == DataVariant::DataInt32 ? static_cast<const DataInt32 *>(data()) : nullptr;
  }
  const DataFloat *data_as_DataFloat() const {
    return data_type() == DataVariant::DataFloat ? static_cast<const DataFloat *>(data()) : nullptr;
  }
  const DataUint32 *data_as_DataUint32() const {
    return data_type() == DataVariant::DataUint32 ? static_cast<const DataUint32 *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyDataVariant(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DataInt32 *UniformParameter::data_as<DataInt32>() const {
  return data_as_DataInt32();
}

template<> inline const DataFloat *UniformParameter::data_as<DataFloat>() const {
  return data_as_DataFloat();
}

template<> inline const DataUint32 *UniformParameter::data_as<DataUint32>() const {
  return data_as_DataUint32();
}

struct UniformParameterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UniformParameter::VT_NAME, name);
  }
  void add_type(ParameterType type) {
    fbb_.AddElement<int8_t>(UniformParameter::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_data_type(DataVariant data_type) {
    fbb_.AddElement<uint8_t>(UniformParameter::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(UniformParameter::VT_DATA, data);
  }
  explicit UniformParameterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformParameterBuilder &operator=(const UniformParameterBuilder &);
  flatbuffers::Offset<UniformParameter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniformParameter>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformParameter> CreateUniformParameter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ParameterType type = ParameterType::INT32,
    DataVariant data_type = DataVariant::NONE,
    flatbuffers::Offset<void> data = 0) {
  UniformParameterBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<UniformParameter> CreateUniformParameterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ParameterType type = ParameterType::INT32,
    DataVariant data_type = DataVariant::NONE,
    flatbuffers::Offset<void> data = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return tflite::gpu::gl::data::CreateUniformParameter(
      _fbb,
      name__,
      type,
      data_type,
      data);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCESS = 4,
    VT_BINDING = 6,
    VT_DATA_TYPE = 8,
    VT_TYPE = 10,
    VT_SIZE_TYPE = 12,
    VT_SIZE = 14,
    VT_OBJECT_TYPE = 16,
    VT_OBJECT = 18
  };
  AccessType access() const {
    return static_cast<AccessType>(GetField<int8_t>(VT_ACCESS, 0));
  }
  uint32_t binding() const {
    return GetField<uint32_t>(VT_BINDING, 0);
  }
  DataType data_type() const {
    return static_cast<DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  ObjectType type() const {
    return static_cast<ObjectType>(GetField<int8_t>(VT_TYPE, 0));
  }
  ObjectSize size_type() const {
    return static_cast<ObjectSize>(GetField<uint8_t>(VT_SIZE_TYPE, 0));
  }
  const void *size() const {
    return GetPointer<const void *>(VT_SIZE);
  }
  template<typename T> const T *size_as() const;
  const Uint1 *size_as_Uint1() const {
    return size_type() == ObjectSize::Uint1 ? static_cast<const Uint1 *>(size()) : nullptr;
  }
  const Uint2 *size_as_Uint2() const {
    return size_type() == ObjectSize::Uint2 ? static_cast<const Uint2 *>(size()) : nullptr;
  }
  const Uint3 *size_as_Uint3() const {
    return size_type() == ObjectSize::Uint3 ? static_cast<const Uint3 *>(size()) : nullptr;
  }
  ObjectVariant object_type() const {
    return static_cast<ObjectVariant>(GetField<uint8_t>(VT_OBJECT_TYPE, 0));
  }
  const void *object() const {
    return GetPointer<const void *>(VT_OBJECT);
  }
  template<typename T> const T *object_as() const;
  const ObjectData *object_as_ObjectData() const {
    return object_type() == ObjectVariant::ObjectData ? static_cast<const ObjectData *>(object()) : nullptr;
  }
  const ObjectRef *object_as_ObjectRef() const {
    return object_type() == ObjectVariant::ObjectRef ? static_cast<const ObjectRef *>(object()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACCESS) &&
           VerifyField<uint32_t>(verifier, VT_BINDING) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_SIZE_TYPE) &&
           VerifyOffset(verifier, VT_SIZE) &&
           VerifyObjectSize(verifier, size(), size_type()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyOffset(verifier, VT_OBJECT) &&
           VerifyObjectVariant(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Uint1 *Object::size_as<Uint1>() const {
  return size_as_Uint1();
}

template<> inline const Uint2 *Object::size_as<Uint2>() const {
  return size_as_Uint2();
}

template<> inline const Uint3 *Object::size_as<Uint3>() const {
  return size_as_Uint3();
}

template<> inline const ObjectData *Object::object_as<ObjectData>() const {
  return object_as_ObjectData();
}

template<> inline const ObjectRef *Object::object_as<ObjectRef>() const {
  return object_as_ObjectRef();
}

struct ObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_access(AccessType access) {
    fbb_.AddElement<int8_t>(Object::VT_ACCESS, static_cast<int8_t>(access), 0);
  }
  void add_binding(uint32_t binding) {
    fbb_.AddElement<uint32_t>(Object::VT_BINDING, binding, 0);
  }
  void add_data_type(DataType data_type) {
    fbb_.AddElement<int8_t>(Object::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_type(ObjectType type) {
    fbb_.AddElement<int8_t>(Object::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_size_type(ObjectSize size_type) {
    fbb_.AddElement<uint8_t>(Object::VT_SIZE_TYPE, static_cast<uint8_t>(size_type), 0);
  }
  void add_size(flatbuffers::Offset<void> size) {
    fbb_.AddOffset(Object::VT_SIZE, size);
  }
  void add_object_type(ObjectVariant object_type) {
    fbb_.AddElement<uint8_t>(Object::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0);
  }
  void add_object(flatbuffers::Offset<void> object) {
    fbb_.AddOffset(Object::VT_OBJECT, object);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectBuilder &operator=(const ObjectBuilder &);
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    AccessType access = AccessType::READ,
    uint32_t binding = 0,
    DataType data_type = DataType::UNKNOWN,
    ObjectType type = ObjectType::UNKNOWN,
    ObjectSize size_type = ObjectSize::NONE,
    flatbuffers::Offset<void> size = 0,
    ObjectVariant object_type = ObjectVariant::NONE,
    flatbuffers::Offset<void> object = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_size(size);
  builder_.add_binding(binding);
  builder_.add_object_type(object_type);
  builder_.add_size_type(size_type);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  builder_.add_access(access);
  return builder_.Finish();
}

struct ObjectRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GLOBAL_ID = 4
  };
  uint32_t global_id() const {
    return GetField<uint32_t>(VT_GLOBAL_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_GLOBAL_ID) &&
           verifier.EndTable();
  }
};

struct ObjectRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_global_id(uint32_t global_id) {
    fbb_.AddElement<uint32_t>(ObjectRef::VT_GLOBAL_ID, global_id, 0);
  }
  explicit ObjectRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectRefBuilder &operator=(const ObjectRefBuilder &);
  flatbuffers::Offset<ObjectRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectRef> CreateObjectRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t global_id = 0) {
  ObjectRefBuilder builder_(_fbb);
  builder_.add_global_id(global_id);
  return builder_.Finish();
}

struct ObjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ObjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ObjectData::VT_DATA, data);
  }
  explicit ObjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectDataBuilder &operator=(const ObjectDataBuilder &);
  flatbuffers::Offset<ObjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectData> CreateObjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ObjectDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectData> CreateObjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return tflite::gpu::gl::data::CreateObjectData(
      _fbb,
      data__);
}

struct CompiledModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETERS = 4,
    VT_SHADERS = 6,
    VT_PROGRAMS = 8
  };
  const Parameters *parameters() const {
    return GetPointer<const Parameters *>(VT_PARAMETERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SHADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Program>> *programs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Program>> *>(VT_PROGRAMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyTable(parameters()) &&
           VerifyOffset(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfStrings(shaders()) &&
           VerifyOffset(verifier, VT_PROGRAMS) &&
           verifier.VerifyVector(programs()) &&
           verifier.VerifyVectorOfTables(programs()) &&
           verifier.EndTable();
  }
};

struct CompiledModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_parameters(flatbuffers::Offset<Parameters> parameters) {
    fbb_.AddOffset(CompiledModel::VT_PARAMETERS, parameters);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> shaders) {
    fbb_.AddOffset(CompiledModel::VT_SHADERS, shaders);
  }
  void add_programs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Program>>> programs) {
    fbb_.AddOffset(CompiledModel::VT_PROGRAMS, programs);
  }
  explicit CompiledModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CompiledModelBuilder &operator=(const CompiledModelBuilder &);
  flatbuffers::Offset<CompiledModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompiledModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompiledModel> CreateCompiledModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Parameters> parameters = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Program>>> programs = 0) {
  CompiledModelBuilder builder_(_fbb);
  builder_.add_programs(programs);
  builder_.add_shaders(shaders);
  builder_.add_parameters(parameters);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompiledModel> CreateCompiledModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Parameters> parameters = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *shaders = nullptr,
    const std::vector<flatbuffers::Offset<Program>> *programs = nullptr) {
  auto shaders__ = shaders ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*shaders) : 0;
  auto programs__ = programs ? _fbb.CreateVector<flatbuffers::Offset<Program>>(*programs) : 0;
  return tflite::gpu::gl::data::CreateCompiledModel(
      _fbb,
      parameters,
      shaders__,
      programs__);
}

struct Parameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DYNAMIC_BATCH = 4
  };
  bool dynamic_batch() const {
    return GetField<uint8_t>(VT_DYNAMIC_BATCH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC_BATCH) &&
           verifier.EndTable();
  }
};

struct ParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dynamic_batch(bool dynamic_batch) {
    fbb_.AddElement<uint8_t>(Parameters::VT_DYNAMIC_BATCH, static_cast<uint8_t>(dynamic_batch), 0);
  }
  explicit ParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ParametersBuilder &operator=(const ParametersBuilder &);
  flatbuffers::Offset<Parameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Parameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<Parameters> CreateParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_batch = false) {
  ParametersBuilder builder_(_fbb);
  builder_.add_dynamic_batch(dynamic_batch);
  return builder_.Finish();
}

inline bool VerifyDataVariant(flatbuffers::Verifier &verifier, const void *obj, DataVariant type) {
  switch (type) {
    case DataVariant::NONE: {
      return true;
    }
    case DataVariant::DataInt32: {
      auto ptr = reinterpret_cast<const DataInt32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataVariant::DataFloat: {
      auto ptr = reinterpret_cast<const DataFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case DataVariant::DataUint32: {
      auto ptr = reinterpret_cast<const DataUint32 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDataVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDataVariant(
        verifier,  values->Get(i), types->GetEnum<DataVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyObjectVariant(flatbuffers::Verifier &verifier, const void *obj, ObjectVariant type) {
  switch (type) {
    case ObjectVariant::NONE: {
      return true;
    }
    case ObjectVariant::ObjectData: {
      auto ptr = reinterpret_cast<const ObjectData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectVariant::ObjectRef: {
      auto ptr = reinterpret_cast<const ObjectRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectVariantVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectVariant(
        verifier,  values->Get(i), types->GetEnum<ObjectVariant>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyObjectSize(flatbuffers::Verifier &verifier, const void *obj, ObjectSize type) {
  switch (type) {
    case ObjectSize::NONE: {
      return true;
    }
    case ObjectSize::Uint1: {
      auto ptr = reinterpret_cast<const Uint1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectSize::Uint2: {
      auto ptr = reinterpret_cast<const Uint2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ObjectSize::Uint3: {
      auto ptr = reinterpret_cast<const Uint3 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyObjectSizeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyObjectSize(
        verifier,  values->Get(i), types->GetEnum<ObjectSize>(i))) {
      return false;
    }
  }
  return true;
}

inline const tflite::gpu::gl::data::CompiledModel *GetCompiledModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::gpu::gl::data::CompiledModel>(buf);
}

inline const tflite::gpu::gl::data::CompiledModel *GetSizePrefixedCompiledModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::gpu::gl::data::CompiledModel>(buf);
}

inline const char *CompiledModelIdentifier() {
  return "AFCM";
}

inline bool CompiledModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, CompiledModelIdentifier());
}

inline bool VerifyCompiledModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::gpu::gl::data::CompiledModel>(CompiledModelIdentifier());
}

inline bool VerifySizePrefixedCompiledModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::gpu::gl::data::CompiledModel>(CompiledModelIdentifier());
}

inline const char *CompiledModelExtension() {
  return "flow";
}

inline void FinishCompiledModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::CompiledModel> root) {
  fbb.Finish(root, CompiledModelIdentifier());
}

inline void FinishSizePrefixedCompiledModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::gpu::gl::data::CompiledModel> root) {
  fbb.FinishSizePrefixed(root, CompiledModelIdentifier());
}

}  // namespace data
}  // namespace gl
}  // namespace gpu
}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_COMPILEDMODEL_TFLITE_GPU_GL_DATA_H_
